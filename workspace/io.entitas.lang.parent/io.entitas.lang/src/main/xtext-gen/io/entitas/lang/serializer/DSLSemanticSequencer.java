/*
 * generated by Xtext 2.11.0
 */
package io.entitas.lang.serializer;

import com.google.inject.Inject;
import io.entitas.lang.dsl.AccessRule;
import io.entitas.lang.dsl.Alias;
import io.entitas.lang.dsl.AliasList;
import io.entitas.lang.dsl.AliasRule;
import io.entitas.lang.dsl.Component;
import io.entitas.lang.dsl.Context;
import io.entitas.lang.dsl.ContextId;
import io.entitas.lang.dsl.ContextScope;
import io.entitas.lang.dsl.ContextScopes;
import io.entitas.lang.dsl.DslPackage;
import io.entitas.lang.dsl.MatcherRule;
import io.entitas.lang.dsl.Namespace;
import io.entitas.lang.dsl.PropertyList;
import io.entitas.lang.dsl.PropertyPrefix;
import io.entitas.lang.dsl.PropertyRules;
import io.entitas.lang.dsl.Root;
import io.entitas.lang.dsl.SingleAlias;
import io.entitas.lang.dsl.Target;
import io.entitas.lang.dsl.TargetId;
import io.entitas.lang.dsl.TargetParameter;
import io.entitas.lang.dsl.TriggerRule;
import io.entitas.lang.dsl.Version;
import io.entitas.lang.services.DSLGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DslPackage.ACCESS_RULE:
				sequence_AccessRule(context, (AccessRule) semanticObject); 
				return; 
			case DslPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case DslPackage.ALIAS_LIST:
				sequence_AliasList(context, (AliasList) semanticObject); 
				return; 
			case DslPackage.ALIAS_RULE:
				sequence_AliasRule(context, (AliasRule) semanticObject); 
				return; 
			case DslPackage.COMPONENT:
				sequence_Component(context, (Component) semanticObject); 
				return; 
			case DslPackage.CONTEXT:
				sequence_Context(context, (Context) semanticObject); 
				return; 
			case DslPackage.CONTEXT_ID:
				sequence_ContextId(context, (ContextId) semanticObject); 
				return; 
			case DslPackage.CONTEXT_SCOPE:
				sequence_ContextScope(context, (ContextScope) semanticObject); 
				return; 
			case DslPackage.CONTEXT_SCOPES:
				sequence_ContextScopes(context, (ContextScopes) semanticObject); 
				return; 
			case DslPackage.MATCHER_RULE:
				sequence_MatcherRule(context, (MatcherRule) semanticObject); 
				return; 
			case DslPackage.NAMESPACE:
				sequence_Namespace(context, (Namespace) semanticObject); 
				return; 
			case DslPackage.PROPERTY_LIST:
				sequence_PropertyList(context, (PropertyList) semanticObject); 
				return; 
			case DslPackage.PROPERTY_PREFIX:
				sequence_PropertyPrefix(context, (PropertyPrefix) semanticObject); 
				return; 
			case DslPackage.PROPERTY_RULES:
				sequence_PropertyRules(context, (PropertyRules) semanticObject); 
				return; 
			case DslPackage.ROOT:
				sequence_Root(context, (Root) semanticObject); 
				return; 
			case DslPackage.SINGLE_ALIAS:
				sequence_SingleAlias(context, (SingleAlias) semanticObject); 
				return; 
			case DslPackage.SYSTEM:
				sequence_System(context, (io.entitas.lang.dsl.System) semanticObject); 
				return; 
			case DslPackage.TARGET:
				sequence_Target(context, (Target) semanticObject); 
				return; 
			case DslPackage.TARGET_ID:
				sequence_TargetId(context, (TargetId) semanticObject); 
				return; 
			case DslPackage.TARGET_PARAMETER:
				sequence_TargetParameter(context, (TargetParameter) semanticObject); 
				return; 
			case DslPackage.TRIGGER_RULE:
				sequence_TriggerRule(context, (TriggerRule) semanticObject); 
				return; 
			case DslPackage.VERSION:
				sequence_Version(context, (Version) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AccessRule returns AccessRule
	 *
	 * Constraint:
	 *     (name=ID ((matcherRule=MatcherRule scope=ContextScope?) | contextRef=[ContextId|ID]))
	 */
	protected void sequence_AccessRule(ISerializationContext context, AccessRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AliasList returns AliasList
	 *
	 * Constraint:
	 *     rules+=AliasRule+
	 */
	protected void sequence_AliasList(ISerializationContext context, AliasList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AliasRule returns AliasRule
	 *
	 * Constraint:
	 *     (target=[TargetId|ID] typeAlias=STRING)
	 */
	protected void sequence_AliasRule(ISerializationContext context, AliasRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ALIAS_RULE__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ALIAS_RULE__TARGET));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.ALIAS_RULE__TYPE_ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.ALIAS_RULE__TYPE_ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAliasRuleAccess().getTargetTargetIdIDTerminalRuleCall_0_0_1(), semanticObject.eGet(DslPackage.Literals.ALIAS_RULE__TARGET, false));
		feeder.accept(grammarAccess.getAliasRuleAccess().getTypeAliasSTRINGTerminalRuleCall_2_0(), semanticObject.getTypeAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     (name=ID (listOfAliases=AliasList | singleAlias=SingleAlias))
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Component returns Component
	 *
	 * Constraint:
	 *     (name=ValidID parameters+=ComponentParameter* scope=ContextScopes? (listOfProperties=PropertyList | propertyPrefix=PropertyPrefix)?)
	 */
	protected void sequence_Component(ISerializationContext context, Component semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextId returns ContextId
	 *
	 * Constraint:
	 *     (name=ID parameters+=ContextParameter?)
	 */
	protected void sequence_ContextId(ISerializationContext context, ContextId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContextScope returns ContextScope
	 *
	 * Constraint:
	 *     reference=[ContextId|ID]
	 */
	protected void sequence_ContextScope(ISerializationContext context, ContextScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.CONTEXT_SCOPE__REFERENCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.CONTEXT_SCOPE__REFERENCE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContextScopeAccess().getReferenceContextIdIDTerminalRuleCall_1_0_1(), semanticObject.eGet(DslPackage.Literals.CONTEXT_SCOPE__REFERENCE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ContextScopes returns ContextScopes
	 *
	 * Constraint:
	 *     references+=[ContextId|ID]+
	 */
	protected void sequence_ContextScopes(ISerializationContext context, ContextScopes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Context returns Context
	 *
	 * Constraint:
	 *     ids+=ContextId+
	 */
	protected void sequence_Context(ISerializationContext context, Context semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MatcherRule returns MatcherRule
	 *
	 * Constraint:
	 *     (allComponents+=[Component|ID]* anyComponents+=[Component|ID]* noneComponents+=[Component|ID]*)
	 */
	protected void sequence_MatcherRule(ISerializationContext context, MatcherRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Namespace returns Namespace
	 *
	 * Constraint:
	 *     name=QualifiedName
	 */
	protected void sequence_Namespace(ISerializationContext context, Namespace semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.NAMESPACE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.NAMESPACE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNamespaceAccess().getNameQualifiedNameParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyList returns PropertyList
	 *
	 * Constraint:
	 *     rules+=PropertyRules+
	 */
	protected void sequence_PropertyList(ISerializationContext context, PropertyList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyPrefix returns PropertyPrefix
	 *
	 * Constraint:
	 *     string=STRING
	 */
	protected void sequence_PropertyPrefix(ISerializationContext context, PropertyPrefix semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY_PREFIX__STRING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY_PREFIX__STRING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyPrefixAccess().getStringSTRINGTerminalRuleCall_2_0(), semanticObject.getString());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PropertyRules returns PropertyRules
	 *
	 * Constraint:
	 *     (name=ID alias=[Alias|ID])
	 */
	protected void sequence_PropertyRules(ISerializationContext context, PropertyRules semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY_RULES__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY_RULES__NAME));
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.PROPERTY_RULES__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.PROPERTY_RULES__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyRulesAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyRulesAccess().getAliasAliasIDTerminalRuleCall_2_0_1(), semanticObject.eGet(DslPackage.Literals.PROPERTY_RULES__ALIAS, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Root returns Root
	 *
	 * Constraint:
	 *     (
	 *         (target=Target? ((typeAliases+=Alias+ systems+=System+) | systems+=System+)) | 
	 *         (target=Target? namespace=Namespace ((typeAliases+=Alias+ systems+=System+) | systems+=System+)) | 
	 *         (
	 *             ((target=Target? context=Context) | (target=Target? namespace=Namespace context=Context) | context=Context) 
	 *             ((typeAliases+=Alias+ systems+=System+) | systems+=System+)
	 *         ) | 
	 *         (
	 *             (
	 *                 (target=Target? ((context=Context typeAliases+=Alias+) | typeAliases+=Alias+)) | 
	 *                 (target=Target? namespace=Namespace ((context=Context typeAliases+=Alias+) | typeAliases+=Alias+)) | 
	 *                 (context=Context typeAliases+=Alias+) | 
	 *                 typeAliases+=Alias+
	 *             )? 
	 *             components+=Component+ 
	 *             systems+=System+
	 *         ) | 
	 *         (typeAliases+=Alias+ systems+=System+) | 
	 *         systems+=System+
	 *     )?
	 */
	protected void sequence_Root(ISerializationContext context, Root semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleAlias returns SingleAlias
	 *
	 * Constraint:
	 *     typeAlias=STRING
	 */
	protected void sequence_SingleAlias(ISerializationContext context, SingleAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.SINGLE_ALIAS__TYPE_ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.SINGLE_ALIAS__TYPE_ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSingleAliasAccess().getTypeAliasSTRINGTerminalRuleCall_1_0(), semanticObject.getTypeAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     System returns System
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=SystemParameter* 
	 *         (reactive?='trigger' scope=ContextScope? triggerRules+=TriggerRule+ (noFilter?='noFilter' | matcherRules=MatcherRule)?)? 
	 *         accessRules+=AccessRule*
	 *     )
	 */
	protected void sequence_System(ISerializationContext context, io.entitas.lang.dsl.System semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TargetId returns TargetId
	 *
	 * Constraint:
	 *     (name=ID parameters+=TargetParameter? version=Version?)
	 */
	protected void sequence_TargetId(ISerializationContext context, TargetId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TargetParameter returns TargetParameter
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_TargetParameter(ISerializationContext context, TargetParameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DslPackage.Literals.TARGET_PARAMETER__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DslPackage.Literals.TARGET_PARAMETER__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTargetParameterAccess().getPathSTRINGTerminalRuleCall_2_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Target returns Target
	 *
	 * Constraint:
	 *     ids+=TargetId+
	 */
	protected void sequence_Target(ISerializationContext context, Target semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TriggerRule returns TriggerRule
	 *
	 * Constraint:
	 *     ((removed?='removed' | added?='added' | removedOrAdded?='removedOrAdded') components+=[Component|ID]+)
	 */
	protected void sequence_TriggerRule(ISerializationContext context, TriggerRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Version returns Version
	 *
	 * Constraint:
	 *     (major=INT (minor=INT patch=INT?)?)
	 */
	protected void sequence_Version(ISerializationContext context, Version semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
