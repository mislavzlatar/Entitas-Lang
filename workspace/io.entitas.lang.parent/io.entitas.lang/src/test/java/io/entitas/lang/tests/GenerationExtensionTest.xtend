/*
 * generated by Xtext 2.11.0
 */
package io.entitas.lang.tests

import com.google.inject.Inject
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith
import io.entitas.lang.dsl.Root
import static extension io.entitas.lang.generator.entitas_csharp.GenerationExtension.*
import static extension io.entitas.lang.generator.entitas_csharp.ContextGenerationExtension.*

@RunWith(XtextRunner)
@InjectWith(DSLInjectorProvider)
class GenerationExtensionTest {
	@Inject
	ParseHelper<Root> parseHelper
	
	@Test
	def void wrapInNamespace() {
		val result = parseHelper.parse('''
			target A
			namespace MyGame
			context Core, Input, Map
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			namespace MyGame {
				public sealed partial class CoreEntity : Entity {}
				public sealed partial class InputEntity : Entity {}
				public sealed partial class MapEntity : Entity {}
			}
		'''.toString, 
		result.context.entityClassDefinitions.wrapWithNamespace(result.namespace.name).toString
		)
	}
	
	@Test
	def void wrapInNamespaceWithDots() {
		val result = parseHelper.parse('''
			target A
			namespace My.Game
			context Core, Input, Map
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			namespace My.Game {
				public sealed partial class CoreEntity : Entity {}
				public sealed partial class InputEntity : Entity {}
				public sealed partial class MapEntity : Entity {}
			}
		'''.toString, 
		result.context.entityClassDefinitions.wrapWithNamespace(result.namespace.name).toString
		)
	}
	
	@Test
	def void wrapInNonExistingNamespace() {
		val result = parseHelper.parse('''
			target A
			context Core, Input, Map
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			public sealed partial class CoreEntity : Entity {}
			public sealed partial class InputEntity : Entity {}
			public sealed partial class MapEntity : Entity {}
		'''.toString, 
		result.context.entityClassDefinitions.wrapWithNamespace(result.namespace?.name).toString
		)
	}
	
	@Test
	def void computeContextComponentMapSingleRoot() {
		val result = parseHelper.parse('''
			target CSharp
			context Core
			comp A
			comp B
			comp C
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		val contextComponentMap = newImmutableList(result).computeContextComponentMap("Core")
		
		Assert.assertEquals(1, contextComponentMap.size)
	}
	
	@Test
	def void computeContextComponentMapMultipleRoots() {
		val result1 = parseHelper.parse('''
			target CSharp
			context Core, Input, Map
			comp A in Core, Map, Input
			comp B
		''')
		Assert.assertNotNull(result1)
		Assert.assertTrue(result1.eResource.errors.isEmpty)
		
		val result2 = parseHelper.parse('''
			context Core, Input, Map
			comp C in Core, Map
		''')
		Assert.assertNotNull(result2)
		Assert.assertTrue(result2.eResource.errors.isEmpty)
		
		val contextComponentMap = newImmutableList(result1, result2).computeContextComponentMap("Core")
		
		Assert.assertEquals(3, contextComponentMap.size)
	}
	
	@Test
	def void componentsLookupForSingleRootAndSingleContext() {
		val result = parseHelper.parse('''
			target CSharp
			context Core
			comp A
			comp B
			comp C
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			public static class CoreComponentsLookup {
				public const int A = 0;
				public const int B = 1;
				public const int C = 2;
			
				public const int TotalComponents = 3;
			
				public static readonly string[] componentNames = {
					"A", "B", "C"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent), typeof(BComponent), typeof(CComponent)
				};
			}
		'''.toString, 
		newImmutableList(result).componentLookup("Core").toString
		)
	}
	
	@Test
	def void componentsLookupForSingleRootAndMultipleContext() {
		val result = parseHelper.parse('''
			target CSharp
			context Core, Input, Map
			comp A in Core, Map, Input
			comp B
			comp C in Core, Map
		''')
		Assert.assertNotNull(result)
		Assert.assertTrue(result.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			public static class CoreComponentsLookup {
				public const int A = 0;
				public const int B = 1;
				public const int C = 2;
			
				public const int TotalComponents = 3;
			
				public static readonly string[] componentNames = {
					"A", "B", "C"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent), typeof(BComponent), typeof(CComponent)
				};
			}
			public static class InputComponentsLookup {
				public const int A = 0;
			
				public const int TotalComponents = 1;
			
				public static readonly string[] componentNames = {
					"A"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent)
				};
			}
			public static class MapComponentsLookup {
				public const int A = 0;
				public const int C = 1;
			
				public const int TotalComponents = 2;
			
				public static readonly string[] componentNames = {
					"A", "C"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent), typeof(CComponent)
				};
			}
		'''.toString, 
		newImmutableList(result).componentLookup("Core").toString
		)
	}
	
	@Test
	def void componentsLookupForMultipleRootAndMultipleContext() {
		val result1 = parseHelper.parse('''
			target CSharp
			context Core, Input, Map
			comp A in Core, Map, Input
			comp B
		''')
		Assert.assertNotNull(result1)
		Assert.assertTrue(result1.eResource.errors.isEmpty)
		
		val result2 = parseHelper.parse('''
			context Core, Input, Map
			comp C in Core, Map
		''')
		Assert.assertNotNull(result2)
		Assert.assertTrue(result2.eResource.errors.isEmpty)
		
		Assert.assertEquals('''
			public static class CoreComponentsLookup {
				public const int A = 0;
				public const int B = 1;
				public const int C = 2;
			
				public const int TotalComponents = 3;
			
				public static readonly string[] componentNames = {
					"A", "B", "C"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent), typeof(BComponent), typeof(CComponent)
				};
			}
			public static class InputComponentsLookup {
				public const int A = 0;
			
				public const int TotalComponents = 1;
			
				public static readonly string[] componentNames = {
					"A"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent)
				};
			}
			public static class MapComponentsLookup {
				public const int A = 0;
				public const int C = 1;
			
				public const int TotalComponents = 2;
			
				public static readonly string[] componentNames = {
					"A", "C"
				};
			
				public static readonly System.Type[] componentTypes = {
					typeof(AComponent), typeof(CComponent)
				};
			}
		'''.toString, 
		newImmutableList(result1, result2).componentLookup("Core").toString
		)
	}
	
	@Test
	def void aadUsing() {
		Assert.assertEquals('''
			using Entitas;
			
			public sealed partial class CoreEntity : Entity {}
		'''.toString, 
		'''public sealed partial class CoreEntity : Entity {}'''.addEntitasUsing.toString
		)
	}
}
